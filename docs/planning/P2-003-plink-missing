# P2-003: plink_missing Table Function

## Goal

Implement `plink_missing(path)` — a DuckDB table function that computes
per-variant and per-sample missingness rates from .pgen files using pgenlib's
`PgrGetMissingness()` fast-path, which extracts missingness bitarrays without
full genotype decompression.

## Prerequisites

- P2-001 merged (shared infrastructure in `plink_common.hpp/cpp`)
- P1-003 merged (read_pgen pgenlib integration)
- P1-002 merged (read_psam for sample metadata in sample-mode output)

## Depends On

P2-001 (for shared infrastructure)

## Parallel Group

**B** — Can run in parallel with P2-002, P2-004, P2-005 after P2-001 merges.

## Branch

`feature/P2-003-plink-missing`

---

## File Manifest

### Create

| File | Purpose |
|------|---------|
| `src/plink_missing.cpp` | plink_missing bind, init, scan for both modes |
| `src/include/plink_missing.hpp` | Public interface: `RegisterPlinkMissing()` |
| `test/sql/plink_missing.test` | Positive tests (variant mode) |
| `test/sql/plink_missing_sample.test` | Positive tests (sample mode) |
| `test/sql/plink_missing_negative.test` | Negative tests |

### Modify

| File | Changes |
|------|---------|
| `src/plinking_duck_extension.cpp` | Add `#include "plink_missing.hpp"`, call `RegisterPlinkMissing(loader)` |
| `CMakeLists.txt` | Add `src/plink_missing.cpp` to build |

---

## SQL Interface

```sql
-- Per-variant missingness (default)
SELECT * FROM plink_missing('data/example.pgen');

-- Per-sample missingness
SELECT * FROM plink_missing('data/example.pgen', mode := 'sample');

-- Variant mode with region filter
SELECT * FROM plink_missing('data/example.pgen', region := '1:10000-50000');

-- Sample mode with sample subset
SELECT * FROM plink_missing('data/example.pgen',
    mode := 'sample', samples := ['SAMPLE1', 'SAMPLE3']);

-- QC: filter high-missingness variants
SELECT * FROM plink_missing('data/example.pgen')
WHERE F_MISS < 0.05;

-- QC: identify high-missingness samples
SELECT IID, F_MISS FROM plink_missing('data/example.pgen', mode := 'sample')
WHERE F_MISS > 0.1;
```

---

## Output Schema

### Variant mode (default, `mode := 'variant'`)

| Column | DuckDB Type | Description |
|--------|-------------|-------------|
| CHROM | VARCHAR | Chromosome |
| POS | INTEGER | Base-pair position |
| ID | VARCHAR | Variant identifier |
| REF | VARCHAR | Reference allele |
| ALT | VARCHAR | Alternate allele(s) |
| MISSING_CT | INTEGER | Count of samples with missing genotype |
| OBS_CT | INTEGER | Count of samples with non-missing genotype |
| F_MISS | DOUBLE | Missing rate (MISSING_CT / (MISSING_CT + OBS_CT)) |

One row per variant.

### Sample mode (`mode := 'sample'`)

| Column | DuckDB Type | Description |
|--------|-------------|-------------|
| FID | VARCHAR | Family ID |
| IID | VARCHAR | Individual/sample ID |
| MISSING_CT | INTEGER | Count of variants with missing genotype for this sample |
| OBS_CT | INTEGER | Count of variants with non-missing genotype |
| F_MISS | DOUBLE | Missing rate (MISSING_CT / (MISSING_CT + OBS_CT)) |

One row per sample.

---

## Named Parameters

| Parameter | Type | Default | Purpose |
|-----------|------|---------|---------|
| `pvar` | VARCHAR | auto-discovered | Explicit .pvar/.bim path |
| `psam` | VARCHAR | auto-discovered | Explicit .psam/.fam path |
| `mode` | VARCHAR | `'variant'` | `'variant'` or `'sample'` |
| `samples` | LIST(VARCHAR) | all | Filter to specific sample IDs |
| `region` | VARCHAR | all | Filter to genomic region (`chr:start-end`) |

---

## Implementation

### Architecture: Two Modes

The function operates in two distinct modes with different scan patterns:

**Variant mode**: For each variant, call `PgrGetMissingness()` to get a
bitarray, `PopCount` it to get the missing count, and emit one output row.
This is variant-parallel (same pattern as plink_freq).

**Sample mode**: Requires accumulating per-sample missing counts across all
variants. This needs a two-pass approach:
1. Iterate all variants, calling `PgrGetMissingness()` for each
2. OR the missingness bitarray into per-sample accumulation counters
3. After all variants processed, emit one row per sample

The sample mode cannot be parallelized per-variant in the output sense (all
variants must be scanned before any sample row can be emitted), but the
scanning itself can be parallelized with per-thread accumulation arrays that
are merged at the end.

### Bind phase (PlinkMissingBind)

1. Accept .pgen path as first positional VARCHAR argument
2. Initialize PgenContext via shared utility
3. Detect `mode` parameter: `'variant'` or `'sample'`
4. If `samples` provided: build SampleSubset
5. If `region` provided: resolve VariantRange
6. Register output columns based on mode
7. Load sample metadata (FID, IID) from .psam for sample mode output

### Variant mode scan

Same parallel scan pattern as plink_freq:

```
BATCH_SIZE = 128

while rows_emitted < STANDARD_VECTOR_SIZE:
    batch_start = global.next_variant_idx.fetch_add(BATCH_SIZE)
    if batch_start >= global.end_variant_idx: break

    for vidx in batch_start..min(batch_start + BATCH_SIZE, end):
        if rows_emitted >= STANDARD_VECTOR_SIZE: break

        uintptr_t missingness[BITARRAY_SIZE]
        PgrGetMissingness(sample_include, pssi, sample_ct, vidx,
                         &pgr, missingness, genovec_buf)

        missing_ct = PopcountWords(missingness, word_ct)
        obs_ct = sample_ct - missing_ct
        f_miss = (sample_ct > 0) ? (double)missing_ct / sample_ct : 0.0

        output CHROM, POS, ID, REF, ALT from variant metadata
        output MISSING_CT, OBS_CT, F_MISS

        rows_emitted++

output.SetCardinality(rows_emitted)
```

### Sample mode implementation

Sample mode requires a full variant scan before emitting any rows.
Implementation uses a two-phase approach: parallel accumulation across
threads, then row emission.

At biobank scale (170M variants × 10M samples), single-threaded
accumulation would be too slow. The parallel approach partitions variants
across threads with per-thread count arrays, then merges — adding minimal
complexity for full parallelism.

**Phase 1 (parallel accumulation)**: Each thread claims variant batches
and accumulates into its own per-sample count array. After all variants
are processed, a merge step sums the per-thread arrays.

```cpp
// In global state:
atomic<uint32_t> next_variant_idx{region_start};
atomic<uint32_t> threads_done{0};
uint32_t total_thread_ct;
atomic<bool> merge_done{false};
vector<uint32_t> sample_missing_counts;  // merged result, size = sample_ct
uint32_t total_variant_ct;

// In local state (per-thread):
vector<uint32_t> local_missing_counts;  // size = sample_ct, initialized to 0

// Phase 1a: each thread accumulates its own count array
BATCH_SIZE = 128
while true:
    batch_start = global.next_variant_idx.fetch_add(BATCH_SIZE)
    if batch_start >= region_end: break

    for vidx in batch_start..min(batch_start + BATCH_SIZE, region_end):
        PgrGetMissingness(sample_include, pssi, sample_ct, vidx,
                         &pgr, missingness, genovec_buf)
        for (uint32_t byte_idx = 0; byte_idx < word_ct; byte_idx++):
            uintptr_t word = missingness[byte_idx]
            while (word):
                uint32_t bit_pos = ctzw(word)
                local_missing_counts[byte_idx * BITS_PER_WORD + bit_pos]++
                word &= word - 1  // clear lowest set bit

// Phase 1b: merge per-thread arrays into global result
// Last thread to finish performs the merge
if global.threads_done.fetch_add(1) + 1 == total_thread_ct:
    for each thread's local_missing_counts:
        for (uint32_t s = 0; s < sample_ct; s++):
            global.sample_missing_counts[s] += local_missing_counts[s]
    global.total_variant_ct = region_end - region_start
    global.merge_done.store(true)
else:
    // Spin-wait for merge (brief — only one merge pass needed)
    while !global.merge_done.load(): yield

// Phase 2: emit rows from accumulated counts
while (global.next_sample_idx < sample_ct && rows_emitted < STANDARD_VECTOR_SIZE):
    sidx = global.next_sample_idx.fetch_add(1)
    if (sidx >= sample_ct) break

    missing_ct = global.sample_missing_counts[sidx]
    obs_ct = global.total_variant_ct - missing_ct
    f_miss = (double)missing_ct / global.total_variant_ct

    output FID, IID from sample metadata
    output MISSING_CT, OBS_CT, F_MISS

    rows_emitted++
```

### Local state

```cpp
struct PlinkMissingLocalState : public LocalTableFunctionState {
    plink2::PgenReader pgr;
    unsigned char* pgr_alloc;
    uintptr_t* missingness;             // bitarray buffer (sample_ct bits)
    uintptr_t* genovec_buf;             // scratch buffer for PgrGetMissingness
    vector<uint32_t> local_missing_counts;  // per-thread accumulation (sample mode)
};
```

### Performance profile

**Variant mode**:
- Variant-parallel, fast-path via `PgrGetMissingness()`
- No genotype decompression; only missingness bits extracted
- Throughput comparable to plink_freq

**Sample mode**:
- Requires full variant scan before any output
- Parallel accumulation: each thread maintains its own `uint32_t[sample_ct]`
  count array, variant batches claimed via atomic counter, arrays merged
  after all variants processed
- Memory: O(sample_ct × thread_ct) for accumulation arrays. At 10M
  samples × 8 threads = 320MB — acceptable for biobank-scale machines
- The merge step is O(sample_ct × thread_ct), a single pass after all
  variant scanning is complete

---

## Testing

### Positive tests — variant mode (plink_missing.test)

```sql
require plinking_duck

# Basic variant missingness
query IIIIRI
SELECT CHROM, POS, ID, MISSING_CT, OBS_CT, F_MISS
FROM plink_missing('test/data/example.pgen');
----
(expected values)

# rs1: [0/0, 0/1, 1/1, ./.] → 1 missing out of 4
query IIIR
SELECT ID, MISSING_CT, OBS_CT, F_MISS
FROM plink_missing('test/data/example.pgen') WHERE ID = 'rs1';
----
rs1	1	3	0.25

# rs2: [0/1, 0/1, 0/0, 1/1] → 0 missing out of 4
query IIIR
SELECT ID, MISSING_CT, OBS_CT, F_MISS
FROM plink_missing('test/data/example.pgen') WHERE ID = 'rs2';
----
rs2	0	4	0.0

# Row count matches variant count
query I
SELECT COUNT(*) FROM plink_missing('test/data/example.pgen');
----
4

# F_MISS between 0 and 1
query I
SELECT COUNT(*) FROM plink_missing('test/data/example.pgen')
WHERE F_MISS < 0.0 OR F_MISS > 1.0;
----
0

# MISSING_CT + OBS_CT = sample_ct (constant)
query I
SELECT COUNT(DISTINCT (MISSING_CT + OBS_CT))
FROM plink_missing('test/data/example.pgen');
----
1

# Region filtering
query I
SELECT COUNT(*) FROM plink_missing('test/data/example.pgen',
    region := '1:10000-20000');
----
2
```

### Positive tests — sample mode (plink_missing_sample.test)

```sql
require plinking_duck

# Basic sample missingness
query IIIR
SELECT IID, MISSING_CT, OBS_CT, F_MISS
FROM plink_missing('test/data/example.pgen', mode := 'sample');
----
(expected values)

# SAMPLE4: missing at rs1 and rs3 → 2 missing out of 4 variants
# (check against test VCF genotypes)
query IIR
SELECT MISSING_CT, OBS_CT, F_MISS
FROM plink_missing('test/data/example.pgen', mode := 'sample')
WHERE IID = 'SAMPLE4';
----
(expected values from test data)

# Row count matches sample count
query I
SELECT COUNT(*) FROM plink_missing('test/data/example.pgen', mode := 'sample');
----
4

# Sample subsetting in sample mode
query I
SELECT COUNT(*)
FROM plink_missing('test/data/example.pgen',
    mode := 'sample', samples := ['SAMPLE1', 'SAMPLE2']);
----
2

# MISSING_CT + OBS_CT = variant_ct (constant per sample)
query I
SELECT COUNT(DISTINCT (MISSING_CT + OBS_CT))
FROM plink_missing('test/data/example.pgen', mode := 'sample');
----
1
```

### Negative tests (plink_missing_negative.test)

```sql
require plinking_duck

# File not found
statement error
SELECT * FROM plink_missing('nonexistent.pgen');
----
(error)

# Invalid mode
statement error
SELECT * FROM plink_missing('test/data/example.pgen', mode := 'invalid');
----
(error: mode must be 'variant' or 'sample')

# No arguments
statement error
SELECT * FROM plink_missing();
----
(error)

# Empty region returns 0 rows (variant mode)
query I
SELECT COUNT(*) FROM plink_missing('test/data/example.pgen',
    region := '99:1-100');
----
0
```

---

## Documentation

### Update README.md

```
### plink_missing(path [, pvar, psam, mode, samples, region])
Compute missingness rates per variant or per sample.
Uses pgenlib's fast missingness extraction — no full genotype decompression.

-- Per-variant missingness (default)
SELECT * FROM plink_missing('data/example.pgen');

-- Per-sample missingness
SELECT * FROM plink_missing('data/example.pgen', mode := 'sample');

-- QC: filter high-missingness variants
SELECT * FROM plink_missing('data/example.pgen')
WHERE F_MISS < 0.05;
```

---

## Acceptance Criteria

1. [ ] Variant mode returns correct per-variant missingness for known test data
2. [ ] Sample mode returns correct per-sample missingness
3. [ ] MISSING_CT + OBS_CT = total count (sample_ct or variant_ct) for all rows
4. [ ] F_MISS values are between 0.0 and 1.0
5. [ ] Sample subsetting works in both modes
6. [ ] Region filtering works in variant mode
7. [ ] Invalid mode produces clear error message
8. [ ] Results match plink2 `--missing` output (within tolerance)
9. [ ] All positive and negative tests pass
10. [ ] `make test` passes
11. [ ] README updated
