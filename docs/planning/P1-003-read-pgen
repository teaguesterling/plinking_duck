# P1-003: read_pgen Table Function

## Goal

Implement `read_pgen(path)` — a DuckDB table function that reads PLINK2 .pgen
binary genotype files, combining variant metadata from .pvar and sample
information from .psam, with parallel scan support.

This is the core reader — the primary value proposition of the extension.

**Key reference**: P0-003 (duckhts lessons) directly informs this plan's
implementation patterns — see cross-references throughout.

## Prerequisites

- P0-005 completed (pgenlib linked)
- P1-001 merged (pvar parsing utilities: `ParsePvarHeader`, variant metadata)
- P1-002 merged (psam parsing utilities: `LoadSampleInfo`, sample metadata)

## Depends On

P1-001, P1-002

## Parallel Group

**B** — Begins after Group A (P1-001 + P1-002) is merged.

## Branch

`feature/P1-003-read-pgen`

---

## File Manifest

### Create

| File | Purpose |
|------|---------|
| `src/pgen_reader.cpp` | Bind, init, scan implementations with pgenlib integration |
| `src/include/pgen_reader.hpp` | Public interface: `RegisterPgenReader()` |
| `test/sql/read_pgen.test` | Positive tests |
| `test/sql/read_pgen_negative.test` | Negative and edge case tests |
| `test/data/example.pgen` | Binary genotype file (generated by plink2) |
| `test/data/generate_test_data.sh` | Script to regenerate test .pgen/.pvar/.psam from VCF |
| `test/data/example.vcf` | Source VCF for generating test PLINK files |

### Modify

| File | Changes |
|------|---------|
| `src/plinking_duck_extension.cpp` | Add `#include "pgen_reader.hpp"`, call `RegisterPgenReader(loader)` |

### Reuse (from P1-001, P1-002)

| File | Used for |
|------|----------|
| `src/include/pvar_reader.hpp` | `ParsePvarHeader()` — load variant metadata in bind phase |
| `src/include/psam_reader.hpp` | `LoadSampleInfo()` — load sample metadata in bind phase |

---

## Schema

| Column | DuckDB Type | Source | Notes |
|--------|-------------|--------|-------|
| CHROM | VARCHAR | .pvar | Chromosome |
| POS | INTEGER | .pvar | Position |
| ID | VARCHAR | .pvar | Variant ID |
| REF | VARCHAR | .pvar | Reference allele |
| ALT | VARCHAR | .pvar | Alternate allele(s) |
| genotypes | LIST(TINYINT) | .pgen | Per-sample alt allele counts: 0, 1, 2, NULL |
| dosages | LIST(FLOAT) | .pgen | Optional. Per-sample dosages (0.0–2.0 scale) |
| phased | LIST(BOOLEAN) | .pgen | Optional. Per-sample phase information |

One row per variant. The `genotypes` list has one entry per sample, in the
same order as the .psam file.

### Genotype encoding

| Value | Meaning |
|-------|---------|
| 0 | Homozygous reference |
| 1 | Heterozygous |
| 2 | Homozygous alternate |
| NULL | Missing genotype |

---

## Implementation

### Bind phase (PgenBind)

1. Accept .pgen path as first positional VARCHAR argument
2. **Auto-discover companion files**: Replace `.pgen` extension with `.pvar`
   and `.psam`. Accept explicit overrides via named parameters `pvar` and `psam`.
3. **Initialize PgenFileInfo** (two-phase init per pgenlib API):
   ```
   PreinitPgfi(&pgfi)
   PgfiInitPhase1(path, ...) → get raw_variant_ct, raw_sample_ct
   allocate pgfi_alloc
   PgfiInitPhase2(...) → get max_vrec_width, pgr_alloc_cacheline_ct
   ```
4. **Load variant metadata**: Call `ParsePvarHeader()` from pvar_reader to get
   column names and pre-load all variant records (CHROM, POS, ID, REF, ALT)
   into memory. For typical datasets this is small (variant count × ~5 strings).
   **P0-003 §4.1**: Consider using pgenlib's `LoadMinimalPvar()` from
   `pvar_ffi_support.h` instead — it provides variant IDs, chromosome names,
   positions, and alleles with zero custom parsing code. Custom parsing via
   `ParsePvarHeader()` is appropriate if we need .bim compatibility or extra
   columns; `LoadMinimalPvar()` is simpler if we only need core metadata.
5. **Load sample info**: Call `LoadSampleInfo()` from psam_reader to get
   sample count and IDs.
6. **Validate consistency**:
   - `pgfi.raw_sample_ct` must match psam sample count
   - `pgfi.raw_variant_ct` must match pvar variant count
   - Error clearly if mismatched
7. **Register output columns**: variant metadata + genotypes + optional dosages/phased
8. **Store in bind data**: PgenFileInfo, pgfi_alloc, variant metadata vectors,
   sample info, max_vrec_width, pgr_alloc_cacheline_ct

### Global state (PgenGlobalState)

```cpp
struct PgenGlobalState : public GlobalTableFunctionState {
    atomic<uint32_t> next_variant_idx{0};
    uint32_t total_variants;

    idx_t MaxThreads() const override {
        // One thread per ~1000 variants, capped at 16
        return std::min<idx_t>(total_variants / 1000 + 1, 16);
    }
};
```

### Local state (PgenLocalState)

Each thread gets its own PgenReader (required by pgenlib — readers are not
thread-safe, but PgenFileInfo is shared and immutable after init).

```cpp
struct PgenLocalState : public LocalTableFunctionState {
    plink2::PgenReader pgr;
    unsigned char* pgr_alloc;      // cache-aligned working memory
    uintptr_t* genovec;            // 2-bit packed genotype buffer
    int32_t* genotype_buf;         // expanded to int32 for conversion
    // Optional dosage buffers:
    uintptr_t* dosage_present;
    uint16_t* dosage_main;
    uint32_t dosage_ct;
    bool initialized;
};
```

**Init local**:
```
allocate pgr_alloc (pgr_alloc_cacheline_ct * kCacheline, cache-aligned)
PgrInit(filename, max_vrec_width, &pgfi, &pgr, pgr_alloc)
allocate genovec (sample_ct / 4 + 1 bytes, cache-aligned)
allocate genotype_buf (sample_ct * sizeof(int32_t))
```

### Scan function (PgenScan)

**P0-003 §2.3**: Use batch claiming (`fetch_add(BATCH_SIZE)` where
BATCH_SIZE=64-256) to reduce atomic contention at biobank scale, rather than
single-variant claiming shown below.

```
while rows_emitted < STANDARD_VECTOR_SIZE:
    vidx = global.next_variant_idx.fetch_add(1)
    if vidx >= total_variants: break

    for each projected column:
        if CHROM/POS/ID/REF/ALT:
            read from pre-loaded variant metadata vectors
        if genotypes:
            PgrGet(nullptr, nullptr, sample_ct, vidx, &pgr, genovec)
            GenoarrToInt32sMinus9(genovec, sample_ct, genotype_buf)
            build LIST(TINYINT) vector:
                for each sample: buf[i] == -9 ? NULL : (int8_t)buf[i]
        if dosages:
            PgrGetD(nullptr, nullptr, sample_ct, vidx, &pgr, genovec,
                     dosage_present, dosage_main, &dosage_ct)
            convert to LIST(FLOAT) with NULL for non-dosed samples

    rows_emitted++

output.SetCardinality(rows_emitted)
```

### Projection pushdown (critical)

**P0-003 §2.1**: Use offset-based column index tracking (as duckhts does with
`vep_col_start`, `info_col_start`, etc.) to classify projected columns into
fixed metadata vs. genotype groups.

The `column_ids` from `TableFunctionInitInput` determines which columns DuckDB
needs. **If genotypes/dosages/phased are not in the projection, do NOT call
PgrGet() at all.** This makes queries like `SELECT chrom, pos FROM read_pgen()`
essentially as fast as reading a text file.

Check projection in scan:
```cpp
bool need_genotypes = false;
bool need_dosages = false;
for (auto col_id : bind.projected_columns) {
    if (col_id == bind.genotypes_col_idx) need_genotypes = true;
    if (col_id == bind.dosages_col_idx) need_dosages = true;
}
```

### Named parameters

| Parameter | Type | Default | Purpose |
|-----------|------|---------|---------|
| `pvar` | VARCHAR | auto-discovered | Explicit .pvar/.bim path |
| `psam` | VARCHAR | auto-discovered | Explicit .psam/.fam path |
| `dosages` | BOOLEAN | false | Include dosages column |
| `phased` | BOOLEAN | false | Include phased column |

### Memory management

**P0-003 §3.1**: Use RAII wrappers (unique_ptr with custom deleters) rather
than raw cleanup calls to avoid the cascading-cleanup bugs found in duckhts.
See P0-003 for `UniquePgfi` and `UniquePgr` wrapper examples.

pgenlib requires cache-aligned allocations. Use `plink2::cachealigned_malloc()`
and `plink2::aligned_free()`. All allocations must be freed in destructors:

```cpp
~PgenLocalState() {
    if (initialized) {
        plink2::PglErr reterr;
        plink2::CleanupPgr(&pgr, &reterr);
        plink2::aligned_free(pgr_alloc);
        plink2::aligned_free(genovec);
        free(genotype_buf);
    }
}

// In PgenBindData destructor:
~PgenBindData() {
    plink2::PglErr reterr;
    plink2::CleanupPgfi(&pgfi, &reterr);
    plink2::aligned_free(pgfi_alloc);
}
```

---

## Test Data Generation

### Source VCF (test/data/example.vcf)

Create a minimal VCF with known genotypes for verification:

```vcf
##fileformat=VCFv4.3
##contig=<ID=1,length=100000>
##contig=<ID=2,length=100000>
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	SAMPLE1	SAMPLE2	SAMPLE3	SAMPLE4
1	10000	rs1	A	G	.	.	.	GT	0/0	0/1	1/1	./.
1	20000	rs2	C	T	.	.	.	GT	0/1	0/1	0/0	1/1
1	30000	rs3	G	A	.	.	.	GT	1/1	./.	0/1	0/0
2	15000	rs4	T	C	.	.	.	GT	0/0	0/0	0/1	1/1
```

### Generation script (test/data/generate_test_data.sh)

```bash
#!/bin/bash
# Requires: plink2 in PATH
# Generates .pgen/.pvar/.psam from example.vcf
set -euo pipefail
cd "$(dirname "$0")"
plink2 --vcf example.vcf --make-pgen --out example
```

The generated .pgen, .pvar, and .psam files should be committed to the
repository so tests don't require plink2 at test time. The script is provided
for reproducibility.

---

## Testing

### Positive tests (read_pgen.test)

```sql
require plinking_duck

# Basic read — variant metadata columns
query IIIII
SELECT CHROM, POS, ID, REF, ALT FROM read_pgen('test/data/example.pgen');
----
(expected variant rows)

# Genotype column — LIST(TINYINT) per variant
query II
SELECT ID, genotypes FROM read_pgen('test/data/example.pgen') WHERE ID = 'rs1';
----
rs1	[0, 1, 2, NULL]

# Known genotype values
query II
SELECT ID, genotypes FROM read_pgen('test/data/example.pgen') WHERE ID = 'rs2';
----
rs2	[1, 1, 0, 2]

# Missing genotypes are NULL in list
query I
SELECT genotypes[4] FROM read_pgen('test/data/example.pgen') WHERE ID = 'rs1';
----
NULL

# Projection pushdown — no genotypes column requested (should be fast)
query II
SELECT CHROM, POS FROM read_pgen('test/data/example.pgen');
----
(variant metadata only)

# Row count matches variant count
query I
SELECT COUNT(*) FROM read_pgen('test/data/example.pgen');
----
4

# List length matches sample count
query I
SELECT len(genotypes) FROM read_pgen('test/data/example.pgen') LIMIT 1;
----
4

# Explicit pvar/psam paths
query I
SELECT COUNT(*) FROM read_pgen('test/data/example.pgen',
    pvar := 'test/data/example.pvar',
    psam := 'test/data/example.psam');
----
4

# Genotype value ranges (should only contain 0, 1, 2, NULL)
query I
SELECT COUNT(*) FROM read_pgen('test/data/example.pgen')
WHERE list_contains(genotypes, 3);
----
0
```

### Negative tests (read_pgen_negative.test)

```sql
require plinking_duck

# File not found
statement error
SELECT * FROM read_pgen('nonexistent.pgen');
----
(error with file path)

# Missing companion .pvar
statement error
SELECT * FROM read_pgen('test/data/orphan.pgen');
----
(error: cannot find .pvar)

# Missing companion .psam
# (create test with .pgen + .pvar but no .psam)
statement error
SELECT * FROM read_pgen('test/data/no_psam.pgen');
----
(error: cannot find .psam)

# Mismatched sample count (.psam has different count than .pgen)
statement error
SELECT * FROM read_pgen('test/data/example.pgen',
    psam := 'test/data/mismatched_samples.psam');
----
(error: sample count mismatch)

# Mismatched variant count (.pvar has different count than .pgen)
statement error
SELECT * FROM read_pgen('test/data/example.pgen',
    pvar := 'test/data/mismatched_variants.pvar');
----
(error: variant count mismatch)

# Wrong argument type
statement error
SELECT * FROM read_pgen(42);
----
(type error)

# No arguments
statement error
SELECT * FROM read_pgen();
----
(missing argument)

# Non-pgen file (e.g., pass a .pvar file as .pgen)
statement error
SELECT * FROM read_pgen('test/data/example.pvar');
----
(error: invalid pgen header / not a pgen file)
```

### Edge case test data to create

| File | Content | Tests |
|------|---------|-------|
| `test/data/orphan.pgen` | .pgen without companion .pvar/.psam | Missing companion error |
| `test/data/mismatched_samples.psam` | .psam with wrong sample count | Count mismatch error |
| `test/data/mismatched_variants.pvar` | .pvar with wrong variant count | Count mismatch error |
| `test/data/all_missing.pgen` | .pgen where all genotypes are missing | All NULLs in lists |

---

## Documentation

### Update README.md

```
### read_pgen(path [, pvar, psam, dosages, phased])
Read PLINK2 .pgen binary genotype files.

-- Basic usage (auto-discovers .pvar and .psam)
SELECT * FROM read_pgen('path/to/file.pgen');

-- Explicit companion file paths
SELECT * FROM read_pgen('file.pgen', pvar := 'other.pvar', psam := 'other.psam');

-- Only variant metadata (skips genotype decoding — fast)
SELECT chrom, pos, id FROM read_pgen('file.pgen');

-- Genotype values: 0=hom_ref, 1=het, 2=hom_alt, NULL=missing
SELECT id, genotypes FROM read_pgen('file.pgen');
```

### Code comments

- Document the two-phase pgenlib initialization
- Document the genotype encoding (2-bit packed → int8)
- Document the projection pushdown logic
- Document thread safety model (shared PgenFileInfo, per-thread PgenReader)

---

## Multiallelic Variants

**P0-003 §4.2**: Start with biallelic-only support. Use `PgrGet()` (which
returns the biallelic-compatible 2-bit encoding) and emit a warning for
multiallelic variants. The `allele_idx_offsetsp` from `MinimalPvar` indicates
whether any variants are multiallelic. Add multiallelic support via
`PgrGetM()`/`PgrGetMP()` in a follow-up phase.

---

## Performance Considerations

1. **Projection pushdown** is the single most important optimization. Skipping
   `PgrGet()` when genotypes aren't needed makes metadata-only queries orders
   of magnitude faster.

2. **Parallel scan** via atomic variant counter allows DuckDB to scale across
   cores. Each thread gets its own PgenReader.

3. **Memory**: Each variant's genotype list holds `sample_ct` entries. For
   biobank-scale data (500K samples), this is ~500KB per row. DuckDB's vector
   size (2048 rows) × 500KB = ~1GB per chunk. Monitor memory and consider
   reducing batch size for large sample counts.

4. **List construction**: Building `LIST(TINYINT)` vectors efficiently requires
   using DuckDB's list vector APIs correctly — pre-allocate child vector size,
   set list offsets, then fill child data. Avoid per-element Value construction.

---

## Acceptance Criteria

1. [ ] `read_pgen('file.pgen')` reads genotypes correctly for known test data
2. [ ] Auto-discovery of .pvar and .psam works
3. [ ] Named parameters `pvar` and `psam` override auto-discovery
4. [ ] Genotype values match expected encoding (0, 1, 2, NULL)
5. [ ] Missing genotypes produce NULL in list
6. [ ] Projection pushdown: genotype decoding skipped when not requested
7. [ ] Parallel scan works (multiple threads, consistent results)
8. [ ] File count mismatches produce clear error messages
9. [ ] All positive and negative tests pass
10. [ ] Memory cleanup: no leaks (PgenReader, aligned allocations)
11. [ ] `make test` passes
12. [ ] README updated
